using System.Runtime.InteropServices;

namespace AdmxCodeGen;

internal static class Templates
{
    public static string GetFileHeaderBanner() => $$"""
		//------------------------------------------------------------------------------ 
		// <auto-generated> 
		// This code was generated by a tool.
		// Runtime Version: {{RuntimeInformation.FrameworkDescription}}
		// 
		// Changes to this file may cause incorrect behavior and will be lost if 
		// the code is regenerated. 
		// </auto-generated> 
		//------------------------------------------------------------------------------
		""";

    public static string GetPolicyRenderingTemplate() => """
		{{ for policy in this.policies }}
		namespace {{ this.namespace | escape_namespace }}
		{
			{{ this.using_references }}

			/// <summary>
			{{ policy.display_name | escape_xmldoc }}
			/// </summary>
			/// <remarks>
			{{ policy.explain_text | escape_xmldoc }}
			/// </remarks>
			public sealed class {{ policy.name | escape_type }}Policy : IPolicy
			{
				private static readonly Lazy<{{ policy.name | escape_type }}Policy> _policyFactory = new Lazy<{{ policy.name | escape_type }}Policy>(
					() => new {{ policy.name | escape_type }}Policy(),
					LazyThreadSafetyMode.None);
				
				/// <summary>
				/// A representative singleton instance is provided to make this policy easily accessible from code.
				/// </summary>
				public static {{ policy.name | escape_type }}Policy Instance { get { return _policyFactory.Value; } }

				/// <summary>
				/// Indicates a unique name by which the policy can be identified.
				/// </summary>
				public string PolicyName { get { return {{ policy.name | literal }}; } }

				/// <summary>
				/// Get the namespace the policy belongs to.
				/// </summary>
				public string Namespace { get { return {{ this.namespace | literal }}; } }

				/// <summary>
				/// Gets the alias of a namespace. This alias may not be unique across different namespaces.
				/// </summary>
				public string Prefix { get { return {{ this.prefix | literal }}; } }
				
				/// <summary>
				/// Translate policy names into a form that humans can understand. Available in American English.
				/// </summary>
				public string DisplayName { get { return {{ policy.display_name | literal }}; } }
				
				/// <summary>
				/// Returns contents containing the policy's purpose, usage method, and precautions. Available in American English.
				/// </summary>
				public string ExplainText { get { return {{ policy.explain_text | literal }}; } }

				/// <summary>
				/// Returns whether this policy can be applied to computer targets.
				/// </summary>
				public bool IsMachinePolicy { get { return {{ policy.is_machine_policy | literal }}; } }
				
				/// <summary>
				/// Returns whether this policy can be applied to users or groups.
				/// </summary>
				public bool IsUserPolicy { get { return {{ policy.is_user_policy | literal }}; } }
				
				/// <summary>
				/// Indicates whether this policy can be reset to its state before application.
				/// </summary>
				public bool CanResetPolicy { get { return {{ policy.reset_items | object.size > 0 | literal }} ; } }
				
				/// <summary>
				/// Indicates whether this policy can be activated.
				/// </summary>
				/// <remarks>
				/// Depending on the policy, it may only provide detailed element settings rather than whether to enable it or not.
				/// </remarks>
				public bool CanEnablePolicy { get { return {{ policy.enable_items | object.size > 0 | literal }} ; } }

				/// <summary>
				/// Indicates whether this policy can be deactivated.
				/// </summary>
				/// <remarks>
				/// Depending on the policy, it may only provide detailed element settings rather than whether to enable it or not.
				/// </remarks>
				public bool CanDisablePolicy { get { return {{ policy.disable_items | object.size > 0 | literal }} ; } }
				
				/// <summary>
				/// Indicates whether detailed element settings can be checked or changed.
				/// </summary>
				public bool HasElements { get { return {{ policy.elements | object.size > 0 | literal }} ; } }

				private void AssertPolicyTarget(bool forMachine)
				{
					if (forMachine)
					{
						if (!IsMachinePolicy)
							throw new InvalidOperationException("This policy can not be applied to machine.");
					}
					else
					{
						if (!IsUserPolicy)
							throw new InvalidOperationException("This policy can not be applied to user.");
					}
				}
				
				private bool? HasPolicyConfiguredInternal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					bool? hasEnableConfigured = null;
					bool? hasDisableConfigured = null;

					RegistryFixedItem[] enableItems = new RegistryFixedItem[] {
					{{~ for item in policy.enable_items ~}}
						new RegistryFixedItem { Key = {{item.key | literal}}, ValueName = {{item.value_name | literal}}, Value = {{item.value | literal}}, Delete = {{item.delete | literal}}, },
					{{~ end ~}}
					};

					foreach (RegistryFixedItem eachEnableItem in enableItems)
					{
						GroupPolicyQueryResult queryResult = forMachine ?
							GroupPolicy.GetMachinePolicy(eachEnableItem.Key, eachEnableItem.ValueName, useCriticalPolicySection) :
							accountSid != null ?
							GroupPolicy.GetAccountPolicy(accountSid, eachEnableItem.Key, eachEnableItem.ValueName, useCriticalPolicySection) :
							GroupPolicy.GetUserPolicy(eachEnableItem.Key, eachEnableItem.ValueName, useCriticalPolicySection);

						if (!queryResult.KeyExists || !queryResult.ValueExists)
						{
							hasEnableConfigured = false;
							break;
						}
					}
					
					if (enableItems.Length > 0)
					{
						if (hasEnableConfigured == null)
							hasEnableConfigured = true;
					}

					RegistryFixedItem[] disableItems = new RegistryFixedItem[] {
					{{~ for item in policy.disable_items ~}}
						new RegistryFixedItem { Key = {{item.key | literal}}, ValueName = {{item.value_name | literal}}, Value = {{item.value | literal}}, Delete = {{item.delete | literal}}, },
					{{~ end ~}}
					};
					
					foreach (RegistryFixedItem eachDisableItem in disableItems)
					{
						GroupPolicyQueryResult queryResult = forMachine ?
							GroupPolicy.GetMachinePolicy(eachDisableItem.Key, eachDisableItem.ValueName, useCriticalPolicySection) :
							accountSid != null ?
							GroupPolicy.GetAccountPolicy(accountSid, eachDisableItem.Key, eachDisableItem.ValueName, useCriticalPolicySection) :
							GroupPolicy.GetUserPolicy(eachDisableItem.Key, eachDisableItem.ValueName, useCriticalPolicySection);

						if (!queryResult.KeyExists || !queryResult.ValueExists)
						{
							hasDisableConfigured = false;
							break;
						}
					}
					
					if (disableItems.Length > 0)
					{
						if (hasDisableConfigured == null)
							hasDisableConfigured = true;
					}

					if (hasEnableConfigured == true)
						return true;
					else if (hasDisableConfigured == true)
						return false;
					else
						return null;
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Checks if a policy is configured for the user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether a policy is configured for the user. Returns true if configured, false if not, or null if unable to determine.</returns>
				public bool? HasPolicyConfiguredForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => HasPolicyConfiguredInternal(/* forMachine */ false, null, useCriticalPolicySection);

				/// <summary>
				/// Checks if a policy is configured for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether a policy is configured for the specified account. Returns true if configured, false if not, or null if unable to determine.</returns>
				public bool? HasPolicyConfiguredForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => HasPolicyConfiguredInternal(/* forMachine */ false, accountSid, useCriticalPolicySection);				{{~ end ~}}

				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Checks if a policy is configured for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether a policy is configured for the machine. Returns true if configured, false if not, or null if unable to determine.</returns>
				public bool? HasPolicyConfiguredForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => HasPolicyConfiguredInternal(/* forMachine */ true, null, useCriticalPolicySection);
				{{~ end ~}}

				{{~ if policy.reset_items | object.size > 0 ~}}
				private void ResetPolicyInternal(bool forMachine, string accountSid, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					RegistryRemoveItem[] resetItems = new RegistryRemoveItem[] {
					{{~ for item in policy.reset_items ~}}
						new RegistryRemoveItem { Key = {{item.key | literal}}, ValueName = {{item.value_name | literal}}, IsPrefix = {{item.is_prefix | literal}}, },
					{{~ end ~}}
					};

					foreach (RegistryRemoveItem eachItem in resetItems)
					{
						if (forMachine)
							GroupPolicy.DeleteMachinePolicy(eachItem.Key, eachItem.ValueName, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(eachItem.Key, eachItem.ValueName, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Resets the policy configuration for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the reset operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void ResetPolicyForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => ResetPolicyInternal(/* forMachine */ false, null, retryCount);

				/// <summary>
				/// Resets the policy configuration for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy.</param>
				/// <param name="retryCount">The number of times to retry the reset operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void ResetPolicyForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => ResetPolicyInternal(/* forMachine */ false, accountSid, retryCount);
				{{~ end ~}}

				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Resets the policy configuration for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the reset operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void ResetPolicyForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => ResetPolicyInternal(/* forMachine */ true, null, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				
				{{~ if policy.enable_items | object.size > 0 ~}}
				private void EnablePolicyInternal(bool forMachine, string accountSid, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					RegistryFixedItem[] enableItems = new RegistryFixedItem[] {
					{{~ for item in policy.enable_items ~}}
						new RegistryFixedItem { Key = {{item.key | literal}}, ValueName = {{item.value_name | literal}}, Value = {{item.value | literal}}, Delete = {{item.delete | literal}}, },
					{{~ end ~}}
					};

					foreach (RegistryFixedItem eachItem in enableItems)
					{
						if (forMachine)
							GroupPolicy.SetMachinePolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
							else
								GroupPolicy.SetUserPolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Enables the policy for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the enable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void EnablePolicyForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => EnablePolicyInternal(/* forMachine */ false, null, retryCount);

				/// <summary>
				/// Enables the policy for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to enable the policy.</param>
				/// <param name="retryCount">The number of times to retry the enable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void EnablePolicyForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => EnablePolicyInternal(/* forMachine */ false, accountSid, retryCount);
				{{~ end ~}}

				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Enables the policy for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the enable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void EnablePolicyForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => EnablePolicyInternal(/* forMachine */ true, null, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				
				{{~ if policy.disable_items | object.size > 0 ~}}
				private void DisablePolicyInternal(bool forMachine, string accountSid, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					RegistryFixedItem[] disableItems = new RegistryFixedItem[] {
					{{~ for item in policy.disable_items ~}}
						new RegistryFixedItem { Key = {{item.key | literal}}, ValueName = {{item.value_name | literal}}, Value = {{item.value | literal}}, Delete = {{item.delete | literal}}, },
					{{~ end ~}}
					};
					
					foreach (RegistryFixedItem eachItem in disableItems)
					{
						if (forMachine)
							GroupPolicy.SetMachinePolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
							else
								GroupPolicy.SetUserPolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Disables the policy for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the disable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void DisablePolicyForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => DisablePolicyInternal(/* forMachine */ false, null, retryCount);

				/// <summary>
				/// Disables the policy for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to disable the policy.</param>
				/// <param name="retryCount">The number of times to retry the disable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void DisablePolicyForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => DisablePolicyInternal(/* forMachine */ false, accountSid, retryCount);
				{{~ end ~}}

				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Disables the policy for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the disable operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void DisablePolicyForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => DisablePolicyInternal(/* forMachine */ true, null, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}

				{{~ for item in policy.elements ~}}
				{{ type_name = (item.id | escape_type) + "Element" }}
				{{ property_name = (item.id | escape_type) }}
				
				{{~ ## Begin Boolean Type ## ~}}
				{{~ if item | is_bei ~}}
				{{~ bei = item | to_bei ~}}
				{{~ bei_id = bei.id ~}}
				private bool? {{bei_id | escape_type}}Default
				{
					get
					{
						object elementDefaultValue = {{ bei.default_value | literal }};
						return (bool?)elementDefaultValue;
					}
				}
				
				private bool? Is{{bei_id | escape_type}}EnabledInternal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ bei.item.key | literal }};
					string valueName = {{ bei.item.value_name | literal }};
					object trueValue = {{ bei.true_value | literal }};
					object falseValue = {{ bei.false_value | literal }};
					
					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);

					if (!queryResult.KeyExists || !queryResult.ValueExists)
						return null;
					if (object.Equals(trueValue, queryResult.Value))
						return true;
					if (object.Equals(falseValue, queryResult.Value))
						return false;
					return null;
				}

				private void Enable{{bei_id | escape_type}}Internal(bool forMachine, string accountSid, bool? enable, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ bei.item.key | literal }};
					string valueName = {{ bei.item.value_name | literal }};
					object trueValue = {{ bei.true_value | literal }};
					object falseValue = {{ bei.false_value | literal }};
					
					RegistryFixedItem[] items;
					if (enable.HasValue)
					{
						if (enable.Value)
						{
							items = new RegistryFixedItem[]
							{
							{{~ for subitem in bei.true_items ~}}
								new RegistryFixedItem { Key = {{subitem.key | literal}}, ValueName = {{subitem.value_name | literal}}, Value = {{subitem.value | literal}}, Delete = {{subitem.delete | literal}}, },
							{{~ end ~}}
							};
						}
						else
						{
							items = new RegistryFixedItem[]
							{
							{{~ for subitem in bei.false_items ~}}
								new RegistryFixedItem { Key = {{subitem.key | literal}}, ValueName = {{subitem.value_name | literal}}, Value = {{subitem.value | literal}}, Delete = {{subitem.delete | literal}}, },
							{{~ end ~}}
							};
						}
					}
					else
					{
						items = new RegistryFixedItem[] { };
					}

					if (forMachine)
					{
						if (enable.HasValue)
						{
							GroupPolicy.SetMachinePolicy(key, valueName, enable.Value ? trueValue : falseValue, false, retryCount);
							foreach (RegistryFixedItem eachItem in items)
								GroupPolicy.SetMachinePolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						}
						else
						{
							GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
							foreach (RegistryFixedItem eachItem in items)
								GroupPolicy.DeleteMachinePolicy(eachItem.Key, eachItem.ValueName, retryCount);
						}
					}
					else
					{
						if (enable.HasValue)
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, key, valueName, enable.Value ? trueValue : falseValue, false, retryCount);
							else
								GroupPolicy.SetUserPolicy(key, valueName, enable.Value ? trueValue : falseValue, false, retryCount);
							
							foreach (RegistryFixedItem eachItem in items)
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
								else
									GroupPolicy.SetUserPolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
							}
						}
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);

							foreach (RegistryFixedItem eachItem in items)
							{
								if (accountSid != null)
									GroupPolicy.DeleteAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, retryCount);
								else
									GroupPolicy.DeleteUserPolicy(eachItem.Key, eachItem.ValueName, retryCount);
							}
						}
					}
				}

				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Checks if the {{bei_id | escape_type}} policy element is enabled for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether the policy element is enabled for the user. Returns true if enabled, false if disabled, or null if unable to determine.</returns>
				public bool? Is{{bei_id | escape_type}}EnabledForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Is{{bei_id | escape_type}}EnabledInternal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Enables or disables the {{bei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="enable">True to enable the policy element, false to disable it.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Enable{{bei_id | escape_type}}ForUser(bool enable, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ false, null, enable, retryCount);
				/// <summary>
				/// Resets the {{bei_id | escape_type}} policy element to its default state for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{bei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ false, null, {{bei_id | escape_type}}Default, retryCount);

				/// <summary>
				/// Checks if the {{bei_id | escape_type}} policy element is enabled for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether the policy element is enabled for the specified account. Returns true if enabled, false if disabled, or null if unable to determine.</returns>
				public bool? Is{{bei_id | escape_type}}EnabledForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Is{{bei_id | escape_type}}EnabledInternal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Enables or disables the {{bei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to enable or disable the policy element.</param>
				/// <param name="enable">True to enable the policy element, false to disable it.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Enable{{bei_id | escape_type}}ForAccount(string accountSid, bool enable, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ false, accountSid, enable, retryCount);
				/// <summary>
				/// Resets the {{bei_id | escape_type}} policy element to its default state for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{bei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ false, accountSid, {{bei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Checks if the {{bei_id | escape_type}} policy element is enabled for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>A boolean indicating whether the policy element is enabled for the machine. Returns true if enabled, false if disabled, or null if unable to determine.</returns>
				public bool? Is{{bei_id | escape_type}}EnabledForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Is{{bei_id | escape_type}}EnabledInternal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Enables or disables the {{bei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="enable">True to enable the policy element, false to disable it.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Enable{{bei_id | escape_type}}ForMachine(bool enable, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ true, null, enable, retryCount);
				/// <summary>
				/// Resets the {{bei_id | escape_type}} policy element to its default state for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{bei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Enable{{bei_id | escape_type}}Internal(/* forMachine */ true, null, {{bei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End Boolean Type ## ~}}
				
				{{~ ## Begin Decimal Type ## ~}}
				{{~ if item | is_dei ~}}
				{{~ dei = item | to_dei ~}}
				{{~ dei_id = dei.id ~}}
				private int? {{dei_id | escape_type}}Default
				{
					get
					{
						object elementDefaultValue = {{ dei.default_value | literal }};
						return (int?)elementDefaultValue;
					}
				}
				
				private int? Get{{dei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ dei.item.key | literal }};
					string valueName = {{ dei.item.value_name | literal }};
					object defaultValue = {{ dei.default_value | literal }};
					bool storeAsText = {{ dei.store_as_text | literal }};
					
					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);

					if (!queryResult.KeyExists || !queryResult.ValueExists)
						return null;
					
					int? val = default;
					if (storeAsText)
					{
						string s = queryResult.Value as string ?? string.Empty;
						if (s != null)
						{
							uint temp;
							if (uint.TryParse(s, out temp))
								val = unchecked((int)temp);
						}
					}
					else
						val = (int)queryResult.Value;

					return val;
				}
				
				private void Set{{dei_id | escape_type}}Internal(bool forMachine, string accountSid, int? value, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ dei.item.key | literal }};
					string valueName = {{ dei.item.value_name | literal }};
					object defaultValue = {{ dei.default_value | literal }};
					uint minValue = unchecked((uint)({{ dei.min_value | literal }}));
					uint maxValue = unchecked((uint)({{ dei.max_value | literal }}));
					bool storeAsText = {{ dei.store_as_text | literal }};
					
					if (value.HasValue)
					{
						uint temp = unchecked((uint)value.Value);
						if (temp > maxValue)
							throw new ArgumentException($"A value exceeding the maximum specifiable value was specified. (maximum value: '{maxValue}')", nameof(value));
						if (temp < minValue)
							throw new ArgumentException($"A value exceeding the minimum specifiable value was specified. (minimum value: '{minValue}')", nameof(value));
					}
					
					if (forMachine)
					{
						if (value.HasValue)
						{
							if (storeAsText)
								GroupPolicy.SetMachinePolicy(key, valueName, value.Value.ToString(), false, retryCount);
							else
								GroupPolicy.SetMachinePolicy(key, valueName, value.Value, false, retryCount);
						}
						else
							GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
					}
					else
					{
						if (value.HasValue)
						{
							if (storeAsText)
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, key, valueName, value.Value.ToString(), false, retryCount);
								else
									GroupPolicy.SetUserPolicy(key, valueName, value.Value.ToString(), false, retryCount);
							}
							else
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, key, valueName, value.Value, false, retryCount);
								else
									GroupPolicy.SetUserPolicy(key, valueName, value.Value, false, retryCount);
							}
						}
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{dei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The integer value of the policy element for the user, or null if not set or unable to retrieve.</returns>
				public int? Get{{dei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{dei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{dei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="value">The integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{dei_id | escape_type}}ForUser(int? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ false, null, value, retryCount);
				/// <summary>
				/// Resets the {{dei_id | escape_type}} policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{dei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ false, null, {{dei_id | escape_type}}Default, retryCount);

				/// <summary>
				/// Retrieves the value of the {{dei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The integer value of the policy element for the specified account, or null if not set or unable to retrieve.</returns>
				public int? Get{{dei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{dei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{dei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="value">The integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{dei_id | escape_type}}ForAccount(string accountSid, int? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ false, accountSid, value, retryCount);
				/// <summary>
				/// Resets the {{dei_id | escape_type}} policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{dei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ false, accountSid, {{dei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{dei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The integer value of the policy element for the machine, or null if not set or unable to retrieve.</returns>
				public int? Get{{dei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{dei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{dei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="value">The integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{dei_id | escape_type}}ForMachine(int? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ true, null, value, retryCount);
				/// <summary>
				/// Resets the {{dei_id | escape_type}} policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{dei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{dei_id | escape_type}}Internal(/* forMachine */ true, null, {{dei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End Decimal Type ## ~}}
				
				{{~ ## Begin Enum Type ## ~}}
				{{~ if item | is_eei ~}}
				{{~ eei = item | to_eei ~}}
				{{~ eei_id = eei.id ~}}
				{{~ enum_type_name = (eei_id | escape_type) + "Values" ~}}
				/// <summary>
				/// Represents the possible values for the {{ enum_type_name }} policy element.
				/// </summary>
				public enum {{ enum_type_name }} : int
				{
				{{~ for member in item.enum_member_items ~}}
				    /// <summary>
				    /// Represents the {{ member.member_name | escape_identifier }} option in the {{ enum_type_name }} policy.
				    /// </summary>
				    [PolicyEnumValue({{ member.member_value | literal }}, {{ member.member_value | is_delval | literal }})]
				    {{ member.member_name | escape_identifier }},

				{{~ end ~}}
				}

				private RegistryFixedItem[] Get{{eei_id | escape_type}}RegistryFixedItemsInternal(object memberValue)
				{
					{{~ for member in item.enum_member_items ~}}
					if (object.Equals({{ member.member_value | literal }}, memberValue))
					{
						return new RegistryFixedItem[]
						{
						{{~ for subitem in member.registry_items ~}}
							new RegistryFixedItem { Key = {{subitem.key | literal}}, ValueName = {{subitem.value_name | literal}}, Value = {{subitem.value | literal}}, Delete = {{subitem.delete | literal}}, },
						{{~ end ~}}
						};
					}
					{{~ end ~}}
					return new RegistryFixedItem[] { };
				}

				private {{ enum_type_name }}? {{eei_id | escape_type}}Default
				{
					get
					{
						object elementDefaultValue = {{ eei.default_value | literal }};
						return Helpers.TranslateToEnum<{{ enum_type_name }}>(elementDefaultValue);
					}
				}
				
				private {{ enum_type_name }}? Get{{eei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ eei.item.key | literal }};
					string valueName = {{ eei.item.value_name | literal }};

					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);

					if (!queryResult.KeyExists || !queryResult.ValueExists)
						return null;

					return Helpers.TranslateToEnum<{{ enum_type_name }}>(queryResult.Value);
				}
				
				private void Set{{eei_id | escape_type}}Internal(bool forMachine, string accountSid, {{ enum_type_name }}? value, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ eei.item.key | literal }};
					string valueName = {{ eei.item.value_name | literal }};

					if (value.HasValue)
					{
						object translatedValue = Helpers.TranslateFromEnum(value);
						RegistryFixedItem[] items = Get{{eei_id | escape_type}}RegistryFixedItemsInternal(translatedValue);

						if (forMachine)
						{
							GroupPolicy.SetMachinePolicy(key, valueName, translatedValue, false, retryCount);
							foreach (RegistryFixedItem eachItem in items)
								GroupPolicy.SetMachinePolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
						}
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, key, valueName, translatedValue, false, retryCount);
							else
								GroupPolicy.SetUserPolicy(key, valueName, translatedValue, false, retryCount);
							
							foreach (RegistryFixedItem eachItem in items)
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
								else
									GroupPolicy.SetUserPolicy(eachItem.Key, eachItem.ValueName, eachItem.Value, false, retryCount);
							}
						}
					}
					else
					{
						if (forMachine)
							GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
						}
					}
				}

				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{eei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The {{enum_type_name}} value of the policy element for the user, or null if not set or unable to retrieve.</returns>
				public {{ enum_type_name }}? Get{{eei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{eei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{eei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="value">The {{enum_type_name}} value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{eei_id | escape_type}}ForUser({{ enum_type_name }} value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ false, null, value, retryCount);
				/// <summary>
				/// Resets the {{eei_id | escape_type}} policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{eei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ false, null, {{eei_id | escape_type}}Default, retryCount);

				/// <summary>
				/// Retrieves the value of the {{eei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The {{enum_type_name}} value of the policy element for the specified account, or null if not set or unable to retrieve.</returns>
				public {{ enum_type_name }}? Get{{eei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{eei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{eei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="value">The {{enum_type_name}} value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{eei_id | escape_type}}ForAccount(string accountSid, {{ enum_type_name }} value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ false, accountSid, value, retryCount);
				/// <summary>
				/// Resets the {{eei_id | escape_type}} policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{eei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ false, accountSid, {{eei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{eei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The {{enum_type_name}} value of the policy element for the machine, or null if not set or unable to retrieve.</returns>
				public {{ enum_type_name }}? Get{{eei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{eei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{eei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="value">The {{enum_type_name}} value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{eei_id | escape_type}}ForMachine({{ enum_type_name }} value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ true, null, value, retryCount);
				/// <summary>
				/// Resets the {{eei_id | escape_type}} policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{eei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{eei_id | escape_type}}Internal(/* forMachine */ true, null, {{eei_id | escape_type}}Default, retryCount);
				{{~ end ~}}

				{{~ end ~}}
				{{~ ## End Enum Type ## ~}}
				
				{{~ ## Begin List Type ## ~}}
				{{~ if item | is_lei ~}}
				{{~ lei = item | to_lei ~}}
				{{~ lei_id = lei.id ~}}
				private string[] Get{{lei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ lei.item.key | literal }};
					string valuePrefix = {{ lei.item.value_prefix | literal }};
					
					MultipleGroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicies(key, valuePrefix, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicies(accountSid, key, valuePrefix, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicies(key, valuePrefix, useCriticalPolicySection);

					return queryResult.Results.Select(x => (string)x.Value).ToArray();
				}
				
				private void Replace{{lei_id | escape_type}}Internal(bool forMachine, string accountSid, IEnumerable<string> items, int retryCount, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ lei.item.key | literal }};
					string valuePrefix = {{ lei.item.value_prefix | literal }};

					MultipleGroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicies(key, valuePrefix, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicies(accountSid, key, valuePrefix, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicies(key, valuePrefix, useCriticalPolicySection);
					
					foreach (GroupPolicyQueryResult eachQueryResult in queryResult.Results)
					{
						if (forMachine)
							GroupPolicy.DeleteMachinePolicy(eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
						}
					}
					
					int count = 1;
					foreach (string eachItem in items)
					{
						if (forMachine)
							GroupPolicy.SetMachinePolicy(key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
							else
								GroupPolicy.SetUserPolicy(key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
						}
						count++;
					}
				}
				
				private void Append{{lei_id | escape_type}}Internal(bool forMachine, string accountSid, IEnumerable<string> items, int retryCount, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ lei.item.key | literal }};
					string valuePrefix = {{ lei.item.value_prefix | literal }};
					
					MultipleGroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicies(key, valuePrefix, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicies(accountSid, key, valuePrefix, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicies(key, valuePrefix, useCriticalPolicySection);
					
					int maxNumber = 1;
					foreach (string eachName in queryResult.Results.Select(x => x.ValueName))
					{
						Match match = Regex.Match(eachName, @$"^(?<prefix>.*?)(?<number>\d+)$");
						if (!match.Success)
							continue;
						string prefixExpression = match.Groups["prefix"].Value;
						if (!string.Equals(valuePrefix, prefixExpression, StringComparison.OrdinalIgnoreCase))
							continue;
						string numberExpression = match.Groups["number"].Value;
						int val;
						if (!int.TryParse(numberExpression, out val))
							continue;
						maxNumber = Math.Max(maxNumber, val);
					}

					int count = maxNumber + 1;
					foreach (string eachItem in items)
					{
						if (forMachine)
							GroupPolicy.SetMachinePolicy(key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
							else
								GroupPolicy.SetUserPolicy(key, valuePrefix + count.ToString(), eachItem, {{ lei.expandable | literal }}, retryCount);
						}
						count++;
					}		
				}
				
				private void Reset{{lei_id | escape_type}}Internal(bool forMachine, string accountSid, int retryCount, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ lei.item.key | literal }};
					string valuePrefix = {{ lei.item.value_prefix | literal }};

					MultipleGroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicies(key, valuePrefix, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicies(accountSid, key, valuePrefix, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicies(key, valuePrefix, useCriticalPolicySection);
					
					foreach (GroupPolicyQueryResult eachQueryResult in queryResult.Results)
					{
						if (forMachine)
							GroupPolicy.DeleteMachinePolicy(eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(eachQueryResult.KeyPath, eachQueryResult.ValueName, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the list of items for the {{lei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the items in the policy element for the user.</returns>
				public string[] Get{{lei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{lei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the list of items for the {{lei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="items">The collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Set{{lei_id | escape_type}}ForUser(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				{{~ if lei.additive ~}}
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ false, null, items, retryCount, useCriticalPolicySection);
				{{~ else ~}}
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ false, null, items, retryCount, useCriticalPolicySection);
				{{~ end ~}}
				/// <summary>
				/// Replaces the entire list of items for the {{lei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="items">The new collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Replace{{lei_id | escape_type}}ForUser(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ false, null, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Appends items to the existing list for the {{lei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="items">The collection of items to append to the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Append{{lei_id | escape_type}}ForUser(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ false, null, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Resets the {{lei_id | escape_type}} policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Reset{{lei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Reset{{lei_id | escape_type}}Internal(/* forMachine */ false, null, retryCount, useCriticalPolicySection);

				/// <summary>
				/// Retrieves the list of items for the {{lei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the items in the policy element for the specified account.</returns>
				public string[] Get{{lei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the list of items for the {{lei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="items">The collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Set{{lei_id | escape_type}}ForAccount(string accountSid, IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				{{~ if lei.additive ~}}
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, items, retryCount, useCriticalPolicySection);
				{{~ else ~}}
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, items, retryCount, useCriticalPolicySection);
				{{~ end ~}}
				/// <summary>
				/// Replaces the entire list of items for the {{lei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to replace the policy element.</param>
				/// <param name="items">The new collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Replace{{lei_id | escape_type}}ForAccount(string accountSid, IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Appends items to the existing list for the {{lei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to append to the policy element.</param>
				/// <param name="items">The collection of items to append to the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Append{{lei_id | escape_type}}ForAccount(string accountSid, IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Resets the {{lei_id | escape_type}} policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Reset{{lei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Reset{{lei_id | escape_type}}Internal(/* forMachine */ false, accountSid, retryCount, useCriticalPolicySection);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the list of items for the {{lei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the items in the policy element for the machine.</returns>
				public string[] Get{{lei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{lei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the list of items for the {{lei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="items">The collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Set{{lei_id | escape_type}}ForMachine(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				{{~ if lei.additive ~}}
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ true, null, items, retryCount, useCriticalPolicySection);
				{{~ else ~}}
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ true, null, items, retryCount, useCriticalPolicySection);
				{{~ end ~}}
				/// <summary>
				/// Replaces the entire list of items for the {{lei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="items">The new collection of items to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Replace{{lei_id | escape_type}}ForMachine(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Replace{{lei_id | escape_type}}Internal(/* forMachine */ true, null, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Appends items to the existing list for the {{lei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="items">The collection of items to append to the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Append{{lei_id | escape_type}}ForMachine(IEnumerable<string> items, int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Append{{lei_id | escape_type}}Internal(/* forMachine */ true, null, items, retryCount, useCriticalPolicySection);
				/// <summary>
				/// Resets the {{lei_id | escape_type}} policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				public void Reset{{lei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Reset{{lei_id | escape_type}}Internal(/* forMachine */ true, null, retryCount, useCriticalPolicySection);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End List Type ## ~}}
				
				{{~ ## Begin Long Decimal Type ## ~}}
				{{~ if item | is_ldei ~}}
				{{~ ldei = item | to_ldei ~}}
				{{~ ldei_id = ldei.id ~}}
				private long? {{ledi_id | escape_type}}Default
				{
					get
					{
						object elementDefaultValue = {{ ldei.default_value | literal }};
						return (long?)elementDefaultValue;
					}
				}
				
				private long? Get{{ldei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ ldei.item.key | literal }};
					string valueName = {{ ldei.item.value_name | literal }};
					object defaultValue = {{ ldei.default_value | literal }};
					bool storeAsText = {{ ldei.store_as_text | literal }};
					
					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);

					if (!queryResult.KeyExists || !queryResult.ValueExists)
						return null;
					
					long? val = default;
					if (storeAsText)
					{
						string s = queryResult.Value as string ?? string.Empty;
						if (s != null)
						{
							ulong temp;
							if (ulong.TryParse(s, out temp))
								val = unchecked((long)temp);
						}
					}
					else
						val = (long)queryResult.Value;

					return val;
				}
				
				private void Set{{ldei_id | escape_type}}Internal(bool forMachine, string accountSid, long? value, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ ldei.item.key | literal }};
					string valueName = {{ ldei.item.value_name | literal }};
					object defaultValue = {{ ldei.default_value | literal }};
					ulong minValue = unchecked((ulong)({{ ldei.min_value | literal }}));
					ulong maxValue = unchecked((ulong)({{ ldei.max_value | literal }}));
					bool storeAsText = {{ ldei.store_as_text | literal }};
					
					if (value.HasValue)
					{
						ulong temp = unchecked((ulong)value.Value);
						if (temp > maxValue)
							throw new ArgumentException($"A value exceeding the maximum specifiable value was specified. (maximum value: '{maxValue}')", nameof(value));
						if (temp < minValue)
							throw new ArgumentException($"A value exceeding the minimum specifiable value was specified. (minimum value: '{minValue}')", nameof(value));
					}
					
					if (forMachine)
					{
						if (value.HasValue)
						{
							if (storeAsText)
								GroupPolicy.SetMachinePolicy(key, valueName, value.Value.ToString(), false, retryCount);
							else
								GroupPolicy.SetMachinePolicy(key, valueName, value.Value, false, retryCount);
						}
						else
							GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
					}
					else
					{
						if (value.HasValue)
						{
							if (storeAsText)
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, key, valueName, value.Value.ToString(), false, retryCount);
								else
									GroupPolicy.SetUserPolicy(key, valueName, value.Value.ToString(), false, retryCount);
							}
							else
							{
								if (accountSid != null)
									GroupPolicy.SetAccountPolicy(accountSid, key, valueName, value.Value, false, retryCount);
								else
									GroupPolicy.SetUserPolicy(key, valueName, value.Value, false, retryCount);
							}
						}
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
						}
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{ldei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The long integer value of the policy element for the user, or null if not set or unable to retrieve.</returns>
				public long? Get{{ldei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{ldei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{ldei_id | escape_type}} policy element for the current user.
				/// </summary>
				/// <param name="value">The long integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{ldei_id | escape_type}}ForUser(long? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ false, null, value, retryCount);
				/// <summary>
				/// Resets the {{ldei_id | escape_type}} policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{ldei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ false, null, {{ldei_id | escape_type}}Default, retryCount);

				/// <summary>
				/// Retrieves the value of the {{ldei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The long integer value of the policy element for the specified account, or null if not set or unable to retrieve.</returns>
				public long? Get{{ldei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{ldei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{ldei_id | escape_type}} policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="value">The long integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{ldei_id | escape_type}}ForAccount(string accountSid, long? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ false, accountSid, value, retryCount);
				/// <summary>
				/// Resets the {{ldei_id | escape_type}} policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{ldei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ false, accountSid, {{ldei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{ldei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The long integer value of the policy element for the machine, or null if not set or unable to retrieve.</returns>
				public long? Get{{ldei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{ldei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{ldei_id | escape_type}} policy element for the machine.
				/// </summary>
				/// <param name="value">The long integer value to set for the policy element, or null to clear the setting.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{ldei_id | escape_type}}ForMachine(long? value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ true, null, value, retryCount);
				/// <summary>
				/// Resets the {{ldei_id | escape_type}} policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{ldei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{ldei_id | escape_type}}Internal(/* forMachine */ true, null, {{ldei_id | escape_type}}Default, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End Long Decimal Type ## ~}}
				
				{{~ ## Begin Multi Text Type ## ~}}
				{{~ if item | is_mtei ~}}
				{{~ mtei = item | to_mtei ~}}
				{{~ mtei_id = mtei.id ~}}
				private string[] Get{{mtei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ mtei.item.key | literal }};
					string valueName = {{ mtei.item.value_name | literal }};
					
					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);
					
					IEnumerable<string> casted = queryResult.Value as IEnumerable<string>;
					if (casted == null)
						casted = Enumerable.Empty<string>();
					return casted.ToArray();
				}
				
				private void Set{{mtei_id | escape_type}}Internal(bool forMachine, string accountSid, IEnumerable<string> value, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ mtei.item.key | literal }};
					string valueName = {{ mtei.item.value_name | literal }};
					int maxStrings = {{ mtei.max_strings | literal }};
					int maxLength = {{ mtei.max_length | literal  }};
					string[] finalValue = value.ToArray();
					
					if (maxStrings > 0 && finalValue.Length > maxStrings)
						throw new ArgumentException($"The maximum number of items that can be specified in this setting is more than {maxStrings}.", nameof(value));
					if (finalValue.Any(x => x.Length > maxLength))
						throw new ArgumentException($"Among the specified items, some items exceed the maximum length of {maxLength} characters.", nameof(value));
					
					if (forMachine)
						GroupPolicy.SetMachinePolicy(key, valueName, finalValue, false, retryCount);
					else
					{
						if (accountSid != null)
							GroupPolicy.SetAccountPolicy(accountSid, key, valueName, finalValue, false, retryCount);
						else
							GroupPolicy.SetUserPolicy(key, valueName, finalValue, false, retryCount);
					}
				}
				
				private void Reset{{mtei_id | escape_type}}Internal(bool forMachine, string accountSid, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ mtei.item.key | literal }};
					string valueName = {{ mtei.item.value_name | literal }};
					
					if (forMachine)
						GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
					else
					{
						if (accountSid != null)
							GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
						else
							GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
					}
				}
				
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the values of the {{mtei_id | escape_type}} multi-text policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the values of the policy element for the user.</returns>
				public string[] Get{{mtei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{mtei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the values of the {{mtei_id | escape_type}} multi-text policy element for the current user.
				/// </summary>
				/// <param name="value">The collection of strings to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{mtei_id | escape_type}}ForUser(IEnumerable<string> value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{mtei_id | escape_type}}Internal(/* forMachine */ false, null, value, retryCount);
				/// <summary>
				/// Resets the {{mtei_id | escape_type}} multi-text policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{mtei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{mtei_id | escape_type}}Internal(/* forMachine */ false, null, retryCount);

				/// <summary>
				/// Retrieves the values of the {{mtei_id | escape_type}} multi-text policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the values of the policy element for the specified account.</returns>
				public string[] Get{{mtei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{mtei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the values of the {{mtei_id | escape_type}} multi-text policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="value">The collection of strings to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{mtei_id | escape_type}}ForAccount(string accountSid, IEnumerable<string> value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{mtei_id | escape_type}}Internal(/* forMachine */ false, accountSid, value, retryCount);
				/// <summary>
				/// Resets the {{mtei_id | escape_type}} multi-text policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{mtei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{mtei_id | escape_type}}Internal(/* forMachine */ false, accountSid, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the values of the {{mtei_id | escape_type}} multi-text policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>An array of strings representing the values of the policy element for the machine.</returns>
				public string[] Get{{mtei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{mtei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the values of the {{mtei_id | escape_type}} multi-text policy element for the machine.
				/// </summary>
				/// <param name="value">The collection of strings to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{mtei_id | escape_type}}ForMachine(IEnumerable<string> value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{mtei_id | escape_type}}Internal(/* forMachine */ true, null, value, retryCount);
				/// <summary>
				/// Resets the {{mtei_id | escape_type}} multi-text policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{mtei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{mtei_id | escape_type}}Internal(/* forMachine */ true, null, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End Multi Text Type ## ~}}
				
				{{~ ## Begin Text Type ## ~}}
				{{~ if item | is_tei ~}}
				{{~ tei = item | to_tei ~}}
				{{~ tei_id = tei.id ~}}
				private string Get{{tei_id | escape_type}}Internal(bool forMachine, string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ tei.item.key | literal }};
					string valueName = {{ tei.item.value_name | literal }};
					
					GroupPolicyQueryResult queryResult = forMachine ?
						GroupPolicy.GetMachinePolicy(key, valueName, useCriticalPolicySection) :
						accountSid != null ?
						GroupPolicy.GetAccountPolicy(accountSid, key, valueName, useCriticalPolicySection) :
						GroupPolicy.GetUserPolicy(key, valueName, useCriticalPolicySection);

					if (!queryResult.KeyExists || !queryResult.ValueExists)
						return null;
					
					return (string)queryResult.Value;
				}
				
				private void Set{{tei_id | escape_type}}Internal(bool forMachine, string accountSid, string value, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ tei.item.key | literal }};
					string valueName = {{ tei.item.value_name | literal }};
					int maxLength = {{ tei.max_length | literal }};
					
					if (value != null)
					{
						if (value.Length > maxLength)
							throw new ArgumentException($"The maximum length cannot exceed {maxLength} characters.", nameof(value));
						if (forMachine)
							GroupPolicy.SetMachinePolicy(key, valueName, value, {{ tei.expandable | literal }}, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.SetAccountPolicy(accountSid, key, valueName, value, {{ tei.expandable | literal }}, retryCount);
							else
								GroupPolicy.SetUserPolicy(key, valueName, value, {{ tei.expandable | literal }}, retryCount);
						}
					}
					else
					{
						if (forMachine)
							GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
						else
						{
							if (accountSid != null)
								GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
							else
								GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
						}
					}
				}
				
				private void Reset{{tei_id | escape_type}}Internal(bool forMachine, string accountSid, int retryCount)
				{
					AssertPolicyTarget(forMachine);
					string key = {{ tei.item.key | literal }};
					string valueName = {{ tei.item.value_name | literal }};
					
					if (forMachine)
						GroupPolicy.DeleteMachinePolicy(key, valueName, retryCount);
					else
					{
						if (accountSid != null)
							GroupPolicy.DeleteAccountPolicy(accountSid, key, valueName, retryCount);
						else
							GroupPolicy.DeleteUserPolicy(key, valueName, retryCount);
					}
				}
					
				{{~ if policy.is_user_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{tei_id | escape_type}} text policy element for the current user.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The string value of the policy element for the user.</returns>
				public string Get{{tei_id | escape_type}}ForUser(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{tei_id | escape_type}}Internal(/* forMachine */ false, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{tei_id | escape_type}} text policy element for the current user.
				/// </summary>
				/// <param name="value">The string value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{tei_id | escape_type}}ForUser(string value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{tei_id | escape_type}}Internal(/* forMachine */ false, null, value, retryCount);
				/// <summary>
				/// Resets the {{tei_id | escape_type}} text policy element to its default value for the current user.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{tei_id | escape_type}}ForUser(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{tei_id | escape_type}}Internal(/* forMachine */ false, null, retryCount);

				/// <summary>
				/// Retrieves the value of the {{tei_id | escape_type}} text policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account to check.</param>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The string value of the policy element for the specified account.</returns>
				public string Get{{tei_id | escape_type}}ForAccount(string accountSid, bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{tei_id | escape_type}}Internal(/* forMachine */ false, accountSid, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{tei_id | escape_type}} text policy element for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to set the policy element.</param>
				/// <param name="value">The string value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{tei_id | escape_type}}ForAccount(string accountSid, string value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{tei_id | escape_type}}Internal(/* forMachine */ false, accountSid, value, retryCount);
				/// <summary>
				/// Resets the {{tei_id | escape_type}} text policy element to its default value for a specific account.
				/// </summary>
				/// <param name="accountSid">The security identifier (SID) of the account for which to reset the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{tei_id | escape_type}}ForAccount(string accountSid, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{tei_id | escape_type}}Internal(/* forMachine */ false, accountSid, retryCount);
				{{~ end ~}}
				
				{{~ if policy.is_machine_policy ~}}
				/// <summary>
				/// Retrieves the value of the {{tei_id | escape_type}} text policy element for the machine.
				/// </summary>
				/// <param name="useCriticalPolicySection">Specifies whether to use the critical policy section. Defaults to GroupPolicy.DefaultUseCriticalPolicySection.</param>
				/// <returns>The string value of the policy element for the machine.</returns>
				public string Get{{tei_id | escape_type}}ForMachine(bool useCriticalPolicySection = GroupPolicy.DefaultUseCriticalPolicySection)
				    => Get{{tei_id | escape_type}}Internal(/* forMachine */ true, null, useCriticalPolicySection);
				/// <summary>
				/// Sets the value of the {{tei_id | escape_type}} text policy element for the machine.
				/// </summary>
				/// <param name="value">The string value to set for the policy element.</param>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Set{{tei_id | escape_type}}ForMachine(string value, int retryCount = GroupPolicy.DefaultRetryCount)
				    => Set{{tei_id | escape_type}}Internal(/* forMachine */ true, null, value, retryCount);
				/// <summary>
				/// Resets the {{tei_id | escape_type}} text policy element to its default value for the machine.
				/// </summary>
				/// <param name="retryCount">The number of times to retry the operation if it fails. Defaults to GroupPolicy.DefaultRetryCount.</param>
				public void Reset{{tei_id | escape_type}}ForMachine(int retryCount = GroupPolicy.DefaultRetryCount)
				    => Reset{{tei_id | escape_type}}Internal(/* forMachine */ true, null, retryCount);
				{{~ end ~}}
				
				{{~ end ~}}
				{{~ ## End Text Type ## ~}}
				
				{{~ end ~}}
			}
		}
		{{~ end ~}}
		""";

    public static string GetSupplementRenderingTemplates() => """
		namespace Shared
		{
			{{ this.using_references }}
			{{ this.body }}
		}
		""";

    public static string GetUsingReferences() => """
		using global::System;
		using global::System.Collections;
		using global::System.Collections.Generic;
		using global::System.ComponentModel;
		using global::System.IO;
		using global::System.Linq;
		using global::System.Reflection;
		using global::System.Runtime.InteropServices;
		using global::System.Security.Principal;
		using global::System.Text;
		using global::System.Text.RegularExpressions;
		using global::System.Threading;

		using Shared;
		""";

    public static string GetBaseModels() => """
		internal abstract class RegistryItemBase
		{
			public string Key { get; internal set; } = string.Empty;
			public string ValueName { get; internal set; } = string.Empty;
		}

		internal sealed class RegistryRemoveItem : RegistryItemBase
		{
			public bool IsPrefix { get; internal set; }
		}

		internal sealed class RegistryFixedItem : RegistryItemBase
		{
			public bool Delete { get; internal set; }
			public object Value { get; internal set; }
		}

		internal sealed class RegistryElementItem : RegistryItemBase
		{
			public bool IsPrefix { get; internal set; }
			public Type ValueType { get; internal set; }
		}
		""";

    public static string GetBaseInterfaces() => """
		/// <summary>
		/// An interface that defines the basic properties and behavior of all ADMX policies.
		/// </summary>
		public interface IPolicy
		{
			/// <summary>
			/// Indicates a unique name by which the policy can be identified.
			/// </summary>
			string PolicyName { get; }
			
			/// <summary>
			/// Get the namespace the policy belongs to.
			/// </summary>
			string Namespace { get; }
			
			/// <summary>
			/// Gets the alias of a namespace. This alias may not be unique across different namespaces.
			/// </summary>
			string Prefix { get; }

			/// <summary>
			/// Translate policy names into a form that humans can understand. Available in American English.
			/// </summary>
			string DisplayName { get; }
			
			/// <summary>
			/// Returns contents containing the policy's purpose, usage method, and precautions. Available in American English.
			/// </summary>
			string ExplainText { get; }

			/// <summary>
			/// Returns whether this policy can be applied to computer targets.
			/// </summary>
			bool IsMachinePolicy { get; }
			
			/// <summary>
			/// Returns whether this policy can be applied to users or groups.
			/// </summary>
			bool IsUserPolicy { get; }
			
			/// <summary>
			/// Indicates whether this policy can be reset to its state before application.
			/// </summary>
			bool CanResetPolicy { get; }
			
			/// <summary>
			/// Indicates whether this policy can be activated.
			/// </summary>
			/// <remarks>
			/// Depending on the policy, it may only provide detailed element settings rather than whether to enable it or not.
			/// </remarks>
			bool CanEnablePolicy { get; }
			
			/// <summary>
			/// Indicates whether this policy can be deactivated.
			/// </summary>
			/// <remarks>
			/// Depending on the policy, it may only provide detailed element settings rather than whether to enable it or not.
			/// </remarks>
			bool CanDisablePolicy { get; }
			
			/// <summary>
			/// Indicates whether detailed element settings can be checked or changed.
			/// </summary>
			bool HasElements { get; }
		}
		""";

    public static string GetGroupPolicyObject() => """
		/// <summary>
		/// Represents a Group Policy Object and provides methods to interact with group policies.
		/// </summary>
		internal sealed partial class GroupPolicyObject : IDisposable
		{
		    public GroupPolicyObject()
		    {
		        _groupPolicyObject = new GroupPolicyClass();
		        _groupPolicyObject2 = (IGroupPolicyObject2)_groupPolicyObject;
		    }

		    /// <summary>
		    /// Finalizer for the GroupPolicyObject class.
		    /// </summary>
		    ~GroupPolicyObject()
		        => Dispose(false);

		    /// <summary>
		    /// Disposes of the resources used by the GroupPolicyObject.
		    /// </summary>
		    public void Dispose()
		    {
		        Dispose(true);
		        GC.SuppressFinalize(this);
		    }

		    private void Dispose(bool _)
		    {
		        if (!_disposed)
		        {
		            if (_groupPolicyObject2 != null)
		            {
		                Marshal.ReleaseComObject(_groupPolicyObject2);
		                _groupPolicyObject2 = null;
		            }

		            if (_groupPolicyObject != null)
		            {
		                Marshal.ReleaseComObject(_groupPolicyObject);
		                _groupPolicyObject = null;
		            }

		            _disposed = true;
		        }
		    }

		    private bool _disposed;
		    private IGroupPolicyObject2 _groupPolicyObject2 = default;
		    private GroupPolicyClass _groupPolicyObject = default;

		    private IGroupPolicyObject2 EnsureGroupPolicyObjectReady()
		    {
		        if (_disposed)
		            throw new ObjectDisposedException(nameof(GroupPolicyObject));

				ApartmentState currentState = Thread.CurrentThread.GetApartmentState();
		        if (currentState != ApartmentState.STA)
		            throw new InvalidOperationException(string.Format("Apartment state must be STA. Current state is {0}.", currentState));

		        using (WindowsIdentity identity = WindowsIdentity.GetCurrent())
		        {
		            WindowsPrincipal principal = new WindowsPrincipal(identity);
		            if (!principal.IsInRole(WindowsBuiltInRole.Administrator))
						throw new InvalidOperationException("This library must be run as an administrator.");
		        }

		        if (_groupPolicyObject2 == null || _groupPolicyObject == null)
		            throw new InvalidOperationException("Group Policy Object is not initialized.");

		        return _groupPolicyObject2;
		    }

		    public void OpenLocalMachine()
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
		        gpo.OpenLocalMachineGPO((int)GroupPolicyOpenFlags.LoadRegistry).AssertResultCode();
		    }

		    public void OpenRemoteMachine(string remoteMachineName)
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
		        gpo.OpenRemoteMachineGPO(remoteMachineName, (int)GroupPolicyOpenFlags.LoadRegistry);
		    }

		    public void OpenLocalUserOrGroup(string userOrGroupSid)
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
		        gpo.OpenLocalMachineGPOForPrincipal(userOrGroupSid, (int)GroupPolicyOpenFlags.LoadRegistry);
		    }

		    public void OpenDirectoryService(string path)
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
		        gpo.OpenDSGPO(path, (int)GroupPolicyOpenFlags.LoadRegistry);
		    }

		    public IntPtr GetUnsafeMachineRegistryKey()
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
				IntPtr hKey;
		        gpo.GetRegistryKey((int)GroupPolicySection.Machine, out hKey).AssertResultCode();
		        return hKey;
		    }

		    public IntPtr GetUnsafeUserRegistryKey()
		    {
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();
				IntPtr hKey;
		        gpo.GetRegistryKey((int)GroupPolicySection.User, out hKey).AssertResultCode();
		        return hKey;
		    }

		    public void OpenGroupPolicy(GroupPolicyLocation location, string locationParameter)
		    {
		        switch (location)
		        {
		            case GroupPolicyLocation.ThisComputer:
		                OpenLocalMachine();
		                break;
		            case GroupPolicyLocation.ThisComputersLocalUserOrGroup:
		                OpenLocalUserOrGroup(locationParameter);
		                break;
		            case GroupPolicyLocation.RemoteComputer:
		                OpenRemoteMachine(locationParameter);
		                break;
		            case GroupPolicyLocation.DirectoryService:
		                OpenDirectoryService(locationParameter);
		                break;
		        }
		    }

		    public bool Save(bool isMachine, bool isAdd, int retryCount)
		    {
		        int wait = 1;
		        retryCount = Math.Max(1, retryCount);
		        IGroupPolicyObject2 gpo = EnsureGroupPolicyObjectReady();

		        for (int i = 0; i < retryCount; i++)
		        {
		            try
		            {
		                int code = gpo.Save(isMachine, isAdd,
		                    NativeMethods.REGISTRY_EXTENSION_GUID,
		                    NativeMethods.CLSID_GPESnapIn);
		                return code.IsSuccessCode();
		            }
		            catch (FileLoadException fle)
		            {
		                if (unchecked((uint)fle.HResult) == NativeMethods.ERROR_SHARING_VIOLATION)
		                {
		                    wait += i;
		                    Thread.Sleep(TimeSpan.FromSeconds(wait));
		                }
		            }
		        }

		        return false;
		    }

		    private GroupPolicyQueryResult GetRegistryValueCore(IntPtr hKey, string subKey, string valueName)
		    {
		        int size = 1;
		        byte[] data = new byte[size];

				RegistryValueType type;
		        if (NativeMethods.RegQueryValueExW(
		            hKey, valueName, IntPtr.Zero,
		            out type, data, ref size).IsHasMoreDataCode())
		            data = new byte[size];

		        if (NativeMethods.RegQueryValueExW(
		            hKey, valueName, IntPtr.Zero, out type, data, ref size).IsNotSuccessCode())
		            return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = false, ValueType = RegistryValueType.None, Value = null, };

		        switch (type)
		        {
		            case RegistryValueType.DWord:
		                int dwordVal = (((data[0] | (data[1] << 8)) | (data[2] << 16)) | (data[3] << 24));
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = dwordVal, };

		            case RegistryValueType.DWordBigEndian:
		                int dwordBEVal = (((data[3] | (data[2] << 8)) | (data[1] << 16)) | (data[0] << 24));
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = dwordBEVal, };

		            case RegistryValueType.QWord:
		                uint numLow = (uint)(((data[0] | (data[1] << 8)) | (data[2] << 16)) | (data[3] << 24));
		                uint numHigh = (uint)(((data[4] | (data[5] << 8)) | (data[6] << 16)) | (data[7] << 24));
		                long qwordVal = (long)(((ulong)numHigh << 32) | (ulong)numLow);
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = qwordVal, };

		            case RegistryValueType.MultiString:
		                List<string> strings = new List<string>();
		                string packed = Encoding.Unicode.GetString(data, 0, size);
		                int start = 0;
		                int end = packed.IndexOf('\0', start);

		                while (end > start)
		                {
		                    strings.Add(packed.Substring(start, end - start));
		                    start = end + 1;
		                    end = packed.IndexOf('\0', start);
		                }

		                string[] multiStringVal = strings.ToArray();
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = multiStringVal, };

		            case RegistryValueType.ExpandString:
		                string unexpandedString = Encoding.Unicode.GetString(data, 0, size);
		                string expandableStringVal = unexpandedString.Substring(0, unexpandedString.Length - 1);
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = expandableStringVal, };

		            case RegistryValueType.String:
		                string rawString = Encoding.Unicode.GetString(data, 0, size);
		                string stringVal = rawString.Substring(0, rawString.Length - 1);
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = stringVal, };

		            default:
		                return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = true, ValueExists = true, ValueType = type, Value = data, };
		        }
		    }

		    public GroupPolicyQueryResult GetGroupPolicyCore(bool isMachine, string subKey, string valueName, bool useCriticalPolicySection)
		    {
		        IntPtr criticalSection = useCriticalPolicySection ? NativeMethods.EnterCriticalPolicySection(isMachine) : IntPtr.Zero;
		        IntPtr gphKey = IntPtr.Zero;

		        try
		        {
		            gphKey = isMachine ? GetUnsafeMachineRegistryKey() : GetUnsafeUserRegistryKey();
		            IntPtr hKey = default(IntPtr);

		            int resultCode = NativeMethods.RegOpenKeyExW(
		                gphKey, subKey, ExtendedRegistryOptions.NonVolatile,
		                DesiredSAMPermissions.QueryValue, out hKey);

		            if (resultCode.IsSuccessCode())
		            {
		                try { return GetRegistryValueCore(hKey, subKey, valueName); }
		                finally { NativeMethods.RegCloseKey(hKey); }
		            }

		            return new GroupPolicyQueryResult() { KeyPath = subKey, ValueName = valueName, KeyExists = false, ValueExists = false, ValueType = RegistryValueType.None, Value = null, };
		        }
		        finally
		        {
		            if (criticalSection != IntPtr.Zero)
		            {
		                NativeMethods.LeaveCriticalPolicySection(criticalSection);
		                criticalSection = IntPtr.Zero;
		            }

		            if (gphKey != IntPtr.Zero)
		                NativeMethods.RegCloseKey(gphKey);
		        }
		    }

		    public MultipleGroupPolicyQueryResult GetGroupPoliciesCore(bool isMachine, string subKey, string valueNamePrefix, bool useCriticalPolicySection)
		    {
		        IntPtr criticalSection = useCriticalPolicySection ? NativeMethods.EnterCriticalPolicySection(isMachine) : IntPtr.Zero;

		        try
		        {
		            MultipleGroupPolicyQueryResult list = new MultipleGroupPolicyQueryResult() { Succeed = true, };
		            IntPtr gphKey = isMachine ? GetUnsafeMachineRegistryKey() : GetUnsafeUserRegistryKey();
		            IntPtr hKey = default(IntPtr);

		            if (NativeMethods.RegOpenKeyExW(
		                gphKey, subKey, ExtendedRegistryOptions.NonVolatile,
		                DesiredSAMPermissions.QueryValue, out hKey).IsSuccessCode())
		            {
		                try
		                {
		                    int index = 0;
		                    StringBuilder valueNameBuffer = new StringBuilder(NativeMethods.MAX_REG_VALUE_NAME_SIZE);
		                    int valueNameLength = valueNameBuffer.Capacity + 1;

		                    while (true)
		                    {
		                        int resultCode = NativeMethods.RegEnumValueW(
		                            hKey, index, valueNameBuffer, ref valueNameLength,
		                            IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
		                        if (resultCode.IsSuccessCode())
		                        {
		                            string valueName = valueNameBuffer.ToString();

		                            if (string.IsNullOrWhiteSpace(valueNamePrefix))
		                                list.Results.Add(GetRegistryValueCore(hKey, subKey, valueName));
		                            else if (valueName.StartsWith(valueNamePrefix))
		                                list.Results.Add(GetRegistryValueCore(hKey, subKey, valueName));

		                            index++;
		                            valueNameLength = valueNameBuffer.Capacity + 1;
		                            continue;
		                        }
		                        else if (resultCode.IsErrorNoMoreItemsCode())
		                            break;
		                        else
		                        {
		                            list.Succeed = false;
		                            list.LastErrorCode = resultCode;
		                            return list;
		                        }
		                    }
		                }
		                finally
		                {
		                    NativeMethods.RegCloseKey(hKey);
		                }
		            }

		            return list;
		        }
		        finally
		        {
		            if (criticalSection != IntPtr.Zero)
		            {
		                NativeMethods.LeaveCriticalPolicySection(criticalSection);
		                criticalSection = IntPtr.Zero;
		            }
		        }
		    }

		    public GroupPolicyUpdateResult SetGroupPolicyCore(bool isMachine, string subKey, string valueName, object value, bool requireExpandString, int retryCount)
		    {
		        if (value == null)
		            throw new ArgumentNullException(nameof(value));

		        IntPtr keyValue = IntPtr.Zero;
		        IntPtr gphKey = isMachine ? GetUnsafeMachineRegistryKey() : GetUnsafeUserRegistryKey();
		        IntPtr gphSubKey = default(IntPtr);

		        try
		        {
					RegistryCreationResult flag;
		            if (NativeMethods.RegCreateKeyExW(gphKey, subKey, 0, null, ExtendedRegistryOptions.NonVolatile,
		                DesiredSAMPermissions.Write, IntPtr.Zero, out gphSubKey, out flag).IsNotSuccessCode())
		                return GroupPolicyUpdateResult.CreateOrOpenFailed;

		            int hr = 0;
					
					if (value is int)
					{
						int i = (int)value;
						keyValue = Marshal.AllocHGlobal(Marshal.SizeOf<int>());
						Marshal.WriteInt32(keyValue, i);
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, RegistryValueType.DWord, keyValue, Marshal.SizeOf<int>());
					}
					else if (value is uint)
					{
						uint ui = (uint)value;
						keyValue = Marshal.AllocHGlobal(Marshal.SizeOf<uint>());
						Marshal.WriteInt32(keyValue, unchecked((int)ui));
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, RegistryValueType.DWord, keyValue, Marshal.SizeOf<uint>());
					}
					else if (value is long)
					{
						long l = (long)value;
						keyValue = Marshal.AllocHGlobal(Marshal.SizeOf<long>());
						Marshal.WriteInt64(keyValue, l);
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, RegistryValueType.DWord, keyValue, Marshal.SizeOf<long>());
					}
					else if (value is ulong)
					{
						ulong ul = (ulong)value;
						keyValue = Marshal.AllocHGlobal(Marshal.SizeOf<ulong>());
						Marshal.WriteInt64(keyValue, unchecked((long)ul));
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, RegistryValueType.DWord, keyValue, Marshal.SizeOf<ulong>());
					}
					else if (value is string)
					{
						string s = (string)value;
						keyValue = Marshal.StringToHGlobalUni(s);
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, requireExpandString ? RegistryValueType.ExpandString : RegistryValueType.String, keyValue, s.Length * 2 + 2);
					}
					else if (value is IEnumerable<string>)
					{
						IEnumerable<string> list = (IEnumerable<string>)value;
						var sb = new StringBuilder();
						foreach (var item in list)
							sb.Append(item).Append('\0');
						sb.Append('\0');
						keyValue = Marshal.StringToHGlobalUni(sb.ToString());
						hr = NativeMethods.RegSetValueExW(gphSubKey, valueName, 0, RegistryValueType.MultiString, keyValue, sb.Length * 2);
					}
					else
		                return GroupPolicyUpdateResult.SetFailed;

		            if (hr.IsNotSuccessCode())
		                return GroupPolicyUpdateResult.SetFailed;

		            if (!Save(isMachine, true, retryCount))
		                return GroupPolicyUpdateResult.SaveFailed;

		            return GroupPolicyUpdateResult.UpdateSucceed;
		        }
		        finally
		        {
		            if (keyValue != IntPtr.Zero)
		                Marshal.FreeHGlobal(keyValue);
		            if (gphSubKey != IntPtr.Zero)
		                NativeMethods.RegCloseKey(gphSubKey);
		            if (gphKey != IntPtr.Zero)
		                NativeMethods.RegCloseKey(gphKey);
		        }
		    }

		    public GroupPolicyDeleteResult DeleteGroupPolicyCore(bool isMachine, string subKey, string valueName, int retryCount)
		    {
		        IntPtr gphKey = isMachine ? GetUnsafeMachineRegistryKey() : GetUnsafeUserRegistryKey();
		        IntPtr hKey = default(IntPtr);

		        try
		        {
		            if (NativeMethods.RegOpenKeyExW(
		                gphKey, subKey, ExtendedRegistryOptions.NonVolatile, DesiredSAMPermissions.QueryValue, out hKey)
		                .IsSuccessCode())
		            {
		                NativeMethods.RegCloseKey(hKey);
		                hKey = IntPtr.Zero;

		                if (NativeMethods.RegDeleteKeyExW(gphKey, subKey, DesiredSAMPermissions.Write, 0).IsNotSuccessCode())
		                {
		                    NativeMethods.RegCloseKey(gphKey);
		                    return GroupPolicyDeleteResult.CreateOrOpenFailed;
		                }

		                if (!Save(isMachine, false, retryCount))
		                    return GroupPolicyDeleteResult.SaveFailed;

		                return GroupPolicyDeleteResult.DeleteSucceed;
		            }
		            else
		                return GroupPolicyDeleteResult.NoItemFound;
		        }
		        finally
		        {
		            if (hKey != IntPtr.Zero)
		                NativeMethods.RegCloseKey(hKey);

		            if (gphKey != IntPtr.Zero)
		                NativeMethods.RegCloseKey(gphKey);
		        }
		    }
		}
		""";

    public static string GetInteropCodes() => """		
		[ComImport]
		[Guid("EA502722-A23D-11d1-A7D3-0000F87571E3")]
		internal class GroupPolicyClass { }

		[ComImport]
		[Guid("7E37D5E7-263D-45CF-842B-96A95C63E46C")]
		[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		internal interface IGroupPolicyObject2
		{
		    [return: MarshalAs(UnmanagedType.U4)]
		    int New(
		        [MarshalAs(UnmanagedType.LPWStr)] string pszDomainName,
		        [MarshalAs(UnmanagedType.LPWStr)] string pszDisplayName,
		        [MarshalAs(UnmanagedType.U4)] int dwFlags);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int OpenDSGPO(
		        [MarshalAs(UnmanagedType.LPWStr)] string pszPath,
		        [MarshalAs(UnmanagedType.U4)] int dwFlags);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int OpenLocalMachineGPO(
		        [MarshalAs(UnmanagedType.U4)] int dwFlags);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int OpenRemoteMachineGPO(
		        [MarshalAs(UnmanagedType.LPWStr)] string pszComputerName,
		        [MarshalAs(UnmanagedType.U4)] int dwFlags);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int Save(
		        [MarshalAs(UnmanagedType.Bool)] bool bMachine,
		        [MarshalAs(UnmanagedType.Bool)] bool bAdd,
		        [MarshalAs(UnmanagedType.LPStruct)] Guid pGuidExtension,
		        [MarshalAs(UnmanagedType.LPStruct)] Guid pGuid);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int Delete();

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetName(
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszName,
		        int cchMaxLength);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetDisplayName(
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszName,
		        int cchMaxLength);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int SetDisplayName(
		        [MarshalAs(UnmanagedType.LPWStr)] string pszName);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetPath(
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszPath,
		        int cchMaxPath);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetDSPath(
		        [MarshalAs(UnmanagedType.U4)] int dwSection,
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszPath,
		        int cchMaxPath);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetFileSysPath(
		        [MarshalAs(UnmanagedType.U4)] int dwSection,
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszPath,
		        int cchMaxPath);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetRegistryKey(
		        [MarshalAs(UnmanagedType.U4)] int dwSection,
		        out IntPtr hKey);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetOptions(
		        [MarshalAs(UnmanagedType.U4)] out int dwOptions);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int SetOptions(
		        [MarshalAs(UnmanagedType.U4)] int dwOptions,
		        [MarshalAs(UnmanagedType.U4)] int dwMask);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetType(
		        out IntPtr gpoType);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetMachineName(
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszName,
		        int cchMaxLength);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetPropertySheetPages(
		        out IntPtr hPages,
		        [MarshalAs(UnmanagedType.U4)] out int uPageCount);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int OpenLocalMachineGPOForPrincipal(
		        [MarshalAs(UnmanagedType.LPWStr)] string pszLocalUserOrGroupSID,
		        [MarshalAs(UnmanagedType.U4)] int dwFlags);

		    [return: MarshalAs(UnmanagedType.U4)]
		    int GetRegistryKeyPath(
		        [MarshalAs(UnmanagedType.U4)] int dwSection,
		        [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pszRegistryKeyPath,
		        int cchMaxLength);
		}

		/// <summary>
		/// Group Policy Object open and creation flags
		/// </summary>
		internal enum GroupPolicyOpenFlags : int
		{
		    /// <summary>
		    /// Load the registry files
		    /// </summary>
		    LoadRegistry = 0x00000001,

		    /// <summary>
		    /// Open the GPO as read only
		    /// </summary>
		    ReadOnly = 0x00000002,
		}

		internal enum GroupPolicySection
		{
		    Root = 0,
		    User = 1,
		    Machine = 2,
		}

		internal enum GroupPolicyLocation
		{
		    ThisComputer = 0,
		    ThisComputersLocalUserOrGroup = 1,
		    RemoteComputer = 2,
		    DirectoryService = 3,
		}

		internal static class NativeMethods
		{
		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegOpenKeyExW(
		        IntPtr hKey,
		        string lpSubKey,
		        [MarshalAs(UnmanagedType.U4)] ExtendedRegistryOptions ulOptions,
		        DesiredSAMPermissions samDesired,
		        out IntPtr phkResult);

		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegEnumValueW(
		        IntPtr hKey,
		        [MarshalAs(UnmanagedType.U4)] int dwIndex,
		        StringBuilder lpValueName,
		        [MarshalAs(UnmanagedType.U4)] ref int lpcchValueName,
		        IntPtr lpReserved,
		        [Out] IntPtr lpType,
		        [Out] IntPtr lpData,
		        [In, Out] IntPtr lpcbData);

		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegQueryValueExW(
		        IntPtr hKey,
		        string lpValueName,
		        IntPtr lpReserved,
		        [MarshalAs(UnmanagedType.U4)] out RegistryValueType lpType,
		        [Out] byte[] lpData,
		        [MarshalAs(UnmanagedType.U4)] ref int lpcbData);

		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegSetValueExW(
		        IntPtr hKey,
		        string lpValueName,
		        [MarshalAs(UnmanagedType.U4)] int Reserved,
		        [MarshalAs(UnmanagedType.U4)] RegistryValueType dwType,
		        IntPtr lpData,
		        [MarshalAs(UnmanagedType.U4)] int cbData);

		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegCreateKeyExW(
		        IntPtr hKey,
		        string lpSubKey,
		        [MarshalAs(UnmanagedType.U4)] int Reserved,
		        string lpClass,
		        [MarshalAs(UnmanagedType.U4)] ExtendedRegistryOptions dwOptions,
		        [MarshalAs(UnmanagedType.U4)] DesiredSAMPermissions samDesired,
		        IntPtr lpSecurityAttributes,
		        out IntPtr phkResult,
		        [MarshalAs(UnmanagedType.U4)] out RegistryCreationResult lpdwDisposition);

		    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
		    public static extern int RegDeleteKeyExW(
		        IntPtr hKey,
		        string lpSubKey,
		        DesiredSAMPermissions samDesired,
		        [MarshalAs(UnmanagedType.U4)] int Reserved);

		    [DllImport("advapi32.dll", CharSet = CharSet.None, ExactSpelling = true)]
		    public static extern int RegCloseKey(IntPtr hKey);

		    public static readonly int S_OK = 0x00000000;

		    public static readonly int ERROR_SUCCESS = 0;
		    public static readonly int ERROR_MORE_DATA = 234;
		    public static readonly int ERROR_NO_MORE_ITEMS = 259;
		    public static readonly int ERROR_SHARING_VIOLATION = unchecked((int)0x80070020u);

		    public static readonly int MAX_REG_VALUE_NAME_SIZE = 16383;

		    public static readonly Guid REGISTRY_EXTENSION_GUID =
		        new Guid("35378EAC-683F-11D2-A89A-00C04FBBCFA2");

		    public static readonly Guid CLSID_GPESnapIn =
		        new Guid("8FC0B734-A0E1-11d1-A7D3-0000F87571E3");

		    [return: MarshalAs(UnmanagedType.Bool)]
		    [DllImport("userenv.dll", CharSet = CharSet.None, SetLastError = true, CallingConvention = CallingConvention.Winapi, ExactSpelling = true)]
		    public static extern bool RefreshPolicy(
		        [MarshalAs(UnmanagedType.Bool)] bool bMachine);

		    [return: MarshalAs(UnmanagedType.Bool)]
		    [DllImport("userenv.dll", CharSet = CharSet.None, SetLastError = true, CallingConvention = CallingConvention.Winapi, ExactSpelling = true)]
		    public static extern bool RefreshPolicyEx(
		        [MarshalAs(UnmanagedType.Bool)] bool bMachine,
		        [MarshalAs(UnmanagedType.U4)] int dwOptions);

		    public static readonly int RP_FORCE = 1;

		    [DllImport("userenv.dll", CharSet = CharSet.None, SetLastError = true, CallingConvention = CallingConvention.Winapi, ExactSpelling = true)]
		    public static extern IntPtr EnterCriticalPolicySection(
		        [MarshalAs(UnmanagedType.Bool)] bool bMachine);

		    [return: MarshalAs(UnmanagedType.Bool)]
		    [DllImport("userenv.dll", CharSet = CharSet.None, SetLastError = true, CallingConvention = CallingConvention.Winapi, ExactSpelling = true)]
		    public static extern bool LeaveCriticalPolicySection(
		        IntPtr hSection);

		    public static int AssertResultCode(this int resultCode)
		    {
		        if (resultCode == NativeMethods.S_OK)
		            return resultCode;

		        throw new Win32Exception(resultCode);
		    }

		    public static bool IsSuccessCode(this int resultCode)
		        => resultCode == NativeMethods.S_OK;

		    public static bool IsNotSuccessCode(this int resultCode)
		        => resultCode != NativeMethods.S_OK;

		    public static bool IsHasMoreDataCode(this int resultCode)
		        => resultCode == NativeMethods.ERROR_MORE_DATA;

		    public static bool IsErrorNoMoreItemsCode(this int resultCode)
		        => resultCode == NativeMethods.ERROR_NO_MORE_ITEMS;
		}
		
		[Flags]
		internal enum DesiredSAMPermissions : int
		{
		    None = 0x00000000,
		    QueryValue = 0x00000001,
		    SetValue = 0x00000002,
		    CreateSubKey = 0x00000004,
		    EnumerateSubKeys = 0x00000008,
		    Notify = 0x00000010,
		    CreateLink = 0x00000020,
		    WOW64_32Key = 0x00000200,
		    WOW64_64Key = 0x00000100,
		    WOW64_Res = 0x00000300,
		    Read = 0x00020019,
		    Write = 0x00020006,
		    Execute = 0x00020019,
		    AllAccess = 0x000f003f,
		}

		[Flags]
		internal enum ExtendedRegistryOptions : int
		{
		    NonVolatile = 0x0,
		    Volatile = 0x1,
		    CreateLink = 0x2,
		    BackupRestore = 0x4,
		    OpenLink = 0x8
		}

		/// <summary>
		/// Represents the type of value stored in the registry.
		/// </summary>
		public enum RegistryValueType : int
		{
		    /// <summary>
		    /// No value type.
		    /// </summary>
		    None = 0x0,

		    /// <summary>
		    /// String value type.
		    /// </summary>
		    String = 0x1,

		    /// <summary>
		    /// Expandable string value type.
		    /// </summary>
		    ExpandString = 0x2,

		    /// <summary>
		    /// Binary value type.
		    /// </summary>
		    Binary = 0x3,

		    /// <summary>
		    /// 32-bit unsigned integer value type.
		    /// </summary>
		    DWord = 0x4,

		    /// <summary>
		    /// 32-bit unsigned integer value type (big-endian).
		    /// </summary>
		    DWordBigEndian = 0x5,

		    /// <summary>
		    /// Symbolic link value type.
		    /// </summary>
		    Link = 0x6,

		    /// <summary>
		    /// Multi-string value type.
		    /// </summary>
		    MultiString = 0x7,

		    /// <summary>
		    /// Resource list value type.
		    /// </summary>
		    ResourceList = 0x8,

		    /// <summary>
		    /// 64-bit unsigned integer value type.
		    /// </summary>
		    QWord = 0xb,

		    /// <summary>
		    /// 64-bit unsigned integer value type (little-endian).
		    /// </summary>
		    QWordLittleEndian = 0xb,
		}

		/// <summary>
		/// Flag returned by calling RegCreateKeyEx.
		/// </summary>
		internal enum RegistryCreationResult : int
		{
		    CreatedNewKey = 0x0,
		    OpenedExistingKey = 0x1,
		}
		
		public sealed class GroupPolicyQueryResult
		{
		    /// <summary>
		    /// Gets or sets the key path.
		    /// </summary>
		    public string KeyPath { get; internal set; } = string.Empty;

		    /// <summary>
		    /// Gets or sets a value indicating whether the key exists.
		    /// </summary>
		    public bool KeyExists { get; internal set; } = false;

		    /// <summary>
		    /// Gets or sets the value name.
		    /// </summary>
		    public string ValueName { get; internal set; } = string.Empty;

		    /// <summary>
		    /// Gets or sets a value indicating whether the value exists.
		    /// </summary>
		    public bool ValueExists { get; internal set; } = false;

		    /// <summary>
		    /// Gets or sets the value.
		    /// </summary>
		    public object Value { get; internal set; } = null;

		    /// <summary>
		    /// Gets or sets the value type.
		    /// </summary>
		    public RegistryValueType ValueType { get; internal set; } = RegistryValueType.None;
		}

		/// <summary>
		/// Represents the result of a group policy update operation.
		/// </summary>
		public enum GroupPolicyUpdateResult
		{
		    /// <summary>
		    /// The group policy update operation succeeded.
		    /// </summary>
		    UpdateSucceed = 0,

		    /// <summary>
		    /// Failed to create or open the group policy.
		    /// </summary>
		    CreateOrOpenFailed,

		    /// <summary>
		    /// Failed to save the group policy.
		    /// </summary>
		    SaveFailed,

		    /// <summary>
		    /// Failed to set the group policy.
		    /// </summary>
		    SetFailed,
		}
		
		public sealed class MultipleGroupPolicyQueryResult
		{
		    public int LastErrorCode { get; internal set; } = NativeMethods.S_OK;

		    public bool Succeed { get; internal set; } = false;

		    public string ValuePrefix { get; internal set; } = string.Empty;

		    public List<GroupPolicyQueryResult> Results { get; } = new List<GroupPolicyQueryResult>();
		}
		""";

    public static string GetGroupPolicyMethods() => """
		public static partial class GroupPolicy
		{
		    /// <summary>
		    /// The default number of retry attempts for operations.
		    /// </summary>
		    public const int DefaultRetryCount = 5;
			
			/// <summary>
			/// Default constant that selects whether to enter the critical section when reading policy settings.
			/// </summary>
			/// <remarks>
			/// Because waiting times can be long, critical sections are not used by default.
			/// </remarks>
			public const bool DefaultUseCriticalPolicySection = false;
		}

		// Thread Procedures
		partial class GroupPolicy
		{
		    private static void GetGroupPolicyThreadProc(object parameter)
		    {
		        GetGroupPolicyThreadProcContext context = parameter as GetGroupPolicyThreadProcContext;
		        if (context == null)
		            throw new ArgumentException($"Incompatible parameter type: '{parameter?.GetType()?.Name ?? "(null)"}'");
		        using GroupPolicyObject o = new GroupPolicyObject();
		        o.OpenGroupPolicy(context.Location, context.LocationParameter);
		        context.Result = o.GetGroupPolicyCore(context.IsMachine, context.SubKey, context.ValueName, context.UseCriticalPolicySection);
		    }

		    private static void GetGroupPoliciesThreadProc(object parameter)
		    {
		        GetGroupPoliciesThreadProcContext context = parameter as GetGroupPoliciesThreadProcContext;
		        if (context == null)
		            throw new ArgumentException($"Incompatible parameter type: '{parameter?.GetType()?.Name ?? "(null)"}'");
		        using GroupPolicyObject o = new GroupPolicyObject();
		        o.OpenGroupPolicy(context.Location, context.LocationParameter);
		        context.Result = o.GetGroupPoliciesCore(context.IsMachine, context.SubKey, context.ValueNamePrefix, context.UseCriticalPolicySection);
		    }

		    private static void SetGroupPolicyThreadProc(object parameter)
		    {
		        SetGroupPolicyThreadProcContext context = parameter as SetGroupPolicyThreadProcContext;
		        if (context == null)
		            throw new ArgumentException($"Incompatible parameter type: '{parameter?.GetType()?.Name ?? "(null)"}'");
		        using GroupPolicyObject o = new GroupPolicyObject();
		        o.OpenGroupPolicy(context.Location, context.LocationParameter);
		        context.Result = o.SetGroupPolicyCore(context.IsMachine, context.SubKey, context.ValueName, context.Value, context.RequireExpandString, context.RetryCount);
		    }

		    private static void DeleteGroupPolicyThreadProc(object parameter)
		    {
		        DeleteGroupPolicyThreadProcContext context = parameter as DeleteGroupPolicyThreadProcContext;
		        if (context == null)
		            throw new ArgumentException($"Incompatible parameter type: '{parameter?.GetType()?.Name ?? "(null)"}'");
		        using GroupPolicyObject o = new GroupPolicyObject();
		        o.OpenGroupPolicy(context.Location, context.LocationParameter);
		        context.Result = o.DeleteGroupPolicyCore(context.IsMachine, context.SubKey, context.ValueName, context.RetryCount);
		    }
		}

		// Thread Issuers
		partial class GroupPolicy
		{
		    private static GroupPolicyQueryResult GetGroupPolicyInternal(
		        GroupPolicyLocation location, string locationParameter,
		        bool isMachine, string subKey, string valueName, bool useCriticalPolicySection)
		    {
		        Thread thread = new Thread(GetGroupPolicyThreadProc);
		        if (!thread.TrySetApartmentState(ApartmentState.STA))
		            throw new NotSupportedException("Cannot set the new thread apartment model as STA.");
		        GetGroupPolicyThreadProcContext context = new GetGroupPolicyThreadProcContext { Location = location, LocationParameter = locationParameter, IsMachine = isMachine, SubKey = subKey, ValueName = valueName, UseCriticalPolicySection = useCriticalPolicySection, };
		        thread.Start(context);
		        thread.Join();
		        return context.Result;
		    }

		    private static MultipleGroupPolicyQueryResult GetGroupPoliciesInternal(
		        GroupPolicyLocation location, string locationParameter,
		        bool isMachine, string subKey, string valueNamePrefix, bool useCriticalPolicySection)
		    {
		        Thread thread = new Thread(GetGroupPoliciesThreadProc);
		        if (!thread.TrySetApartmentState(ApartmentState.STA))
		            throw new NotSupportedException("Cannot set the new thread apartment model as STA.");
		        GetGroupPoliciesThreadProcContext context = new GetGroupPoliciesThreadProcContext { Location = location, LocationParameter = locationParameter, IsMachine = isMachine, SubKey = subKey, ValueNamePrefix = valueNamePrefix, UseCriticalPolicySection = useCriticalPolicySection, };
		        thread.Start(context);
		        thread.Join();
		        return context.Result;
		    }

		    private static GroupPolicyUpdateResult SetGroupPolicyInternal(
		        GroupPolicyLocation location, string locationParameter,
		        bool isMachine, string subKey, string valueName, object value, bool requireExpandString, int retryCount)
		    {
		        if (value == null)
		            throw new ArgumentNullException(nameof(value));
		        Thread thread = new Thread(SetGroupPolicyThreadProc);
		        if (!thread.TrySetApartmentState(ApartmentState.STA))
		            throw new NotSupportedException("Cannot set the new thread apartment model as STA.");
		        SetGroupPolicyThreadProcContext context = new SetGroupPolicyThreadProcContext { Location = location, LocationParameter = locationParameter, IsMachine = isMachine, SubKey = subKey, ValueName = valueName, Value = value, RequireExpandString = requireExpandString, RetryCount = retryCount, };
		        thread.Start(context);
		        thread.Join();
		        return context.Result;
		    }

		    private static GroupPolicyDeleteResult DeleteGroupPolicyInternal(
		        GroupPolicyLocation location, string locationParameter,
		        bool isMachine, string subKey, string valueName, int retryCount)
		    {
		        Thread thread = new Thread(DeleteGroupPolicyThreadProc);
		        if (!thread.TrySetApartmentState(ApartmentState.STA))
		            throw new NotSupportedException("Cannot set the new thread apartment model as STA.");
		        DeleteGroupPolicyThreadProcContext context = new DeleteGroupPolicyThreadProcContext { Location = location, LocationParameter = locationParameter, IsMachine = isMachine, SubKey = subKey, ValueName = valueName, RetryCount = retryCount, };
		        thread.Start(context);
		        thread.Join();
		        return context.Result;
		    }
		}

		// Policy Propagation
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Propagates the machine policy.
		    /// </summary>
		    /// <param name="force">Indicates whether to force the policy propagation.</param>
		    /// <returns>True if the policy propagation is successful, otherwise false.</returns>
		    public static bool PropagateMachinePolicy(bool force = false)
		    {
		        return force ?
		            NativeMethods.RefreshPolicyEx(true, NativeMethods.RP_FORCE) :
		            NativeMethods.RefreshPolicy(true);
		    }

		    /// <summary>
		    /// Propagates the user policy.
		    /// </summary>
		    /// <param name="force">Indicates whether to force the policy propagation.</param>
		    /// <returns>True if the policy propagation is successful, otherwise false.</returns>
		    public static bool PropagateUserPolicy(bool force = false)
		    {
		        return force ?
		            NativeMethods.RefreshPolicyEx(false, NativeMethods.RP_FORCE) :
		            NativeMethods.RefreshPolicy(false);
		    }
		}

		// Machine Policy (for This Computer) 
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the machine policy value from the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to retrieve the value from.</param>
		    /// <param name="valueName">The name of the value to retrieve.</param>
		    /// <returns>The <see cref="GroupPolicyQueryResult"/> containing the result of the query.</returns>
		    public static GroupPolicyQueryResult GetMachinePolicy(string subKey, string valueName, bool useCriticalPolicySection = false)
		        => GetGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ true, subKey, valueName, useCriticalPolicySection);

		    /// <summary>
		    /// Retrieves multiple group policy values for the machine.
		    /// </summary>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetMachinePolicies(string subKey, string valueNamePrefix, bool useCriticalPolicySection = false)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ true, subKey, valueNamePrefix, useCriticalPolicySection);

		    /// <summary>
		    /// Sets the machine policy value for the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to set the value for.</param>
		    /// <param name="valueName">The name of the value to set.</param>
		    /// <param name="value">The value to set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retry attempts for the operation. Default is 5.</param>
		    /// <returns>The <see cref="GroupPolicyUpdateResult"/> indicating the result of the operation.</returns>
		    public static GroupPolicyUpdateResult SetMachinePolicy(string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ true, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the machine policy value for the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to delete the value from.</param>
		    /// <param name="valueName">The name of the value to delete.</param>
		    /// <param name="retryCount">The number of retry attempts for the operation. Default is 5.</param>
		    /// <returns>The <see cref="GroupPolicyDeleteResult"/> indicating the result of the operation.</returns>
		    public static GroupPolicyDeleteResult DeleteMachinePolicy(string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ true, subKey, valueName, retryCount);
		}

		// User Policy (for This Computer)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the user policy value from the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to retrieve the value from.</param>
		    /// <param name="valueName">The name of the value to retrieve.</param>
		    /// <returns>The <see cref="GroupPolicyQueryResult"/> containing the result of the query.</returns>
		    public static GroupPolicyQueryResult GetUserPolicy(string subKey, string valueName, bool useCriticalPolicySection = false)
		        => GetGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ false, subKey, valueName, useCriticalPolicySection);

		    /// <summary>
		    /// Retrieves multiple group policy values for the current user.
		    /// </summary>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetUserPolicies(string subKey, string valueNamePrefix, bool useCriticalPolicySection = false)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ false, subKey, valueNamePrefix, useCriticalPolicySection);

		    /// <summary>
		    /// Sets the user policy value for the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to set the value for.</param>
		    /// <param name="valueName">The name of the value to set.</param>
		    /// <param name="value">The value to set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retry attempts for the operation. Default is 5.</param>
		    /// <returns>The <see cref="GroupPolicyUpdateResult"/> indicating the result of the operation.</returns>
		    public static GroupPolicyUpdateResult SetUserPolicy(string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ false, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the user policy value for the specified subkey and value name.
		    /// </summary>
		    /// <param name="subKey">The subkey to delete the value from.</param>
		    /// <param name="valueName">The name of the value to delete.</param>
		    /// <param name="retryCount">The number of retry attempts for the operation. Default is 5.</param>
		    /// <returns>The <see cref="GroupPolicyDeleteResult"/> indicating the result of the operation.</returns>
		    public static GroupPolicyDeleteResult DeleteUserPolicy(string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.ThisComputer, string.Empty, /* isMachine */ false, subKey, valueName, retryCount);
		}

		// User, Group (Account) Policy (for This Computer)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the account policy for the specified account.
		    /// </summary>
		    /// <param name="accountSid">The SID of the account.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <returns>The query result of the account policy.</returns>
		    public static GroupPolicyQueryResult GetAccountPolicy(string accountSid, string subKey, string valueName, bool useCriticalPolicySection = false)
		        => GetGroupPolicyInternal(GroupPolicyLocation.ThisComputersLocalUserOrGroup, accountSid, /* isMachine */ false, subKey, valueName, useCriticalPolicySection);

		    /// <summary>
		    /// Retrieves multiple group policy values for the specified account.
		    /// </summary>
		    /// <param name="accountSid">The security identifier (SID) of the account.</param>
		    /// <param name="subKey">The subkey of the registry key to retrieve the values from.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>A <see cref="MultipleGroupPolicyQueryResult"/> object containing the group policy values.</returns>
		    public static MultipleGroupPolicyQueryResult GetAccountPolicies(string accountSid, string subKey, string valueNamePrefix, bool useCriticalPolicySection = false)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.ThisComputersLocalUserOrGroup, accountSid, /* isMachine */ false, subKey, valueNamePrefix, useCriticalPolicySection);

		    /// <summary>
		    /// Sets the account policy for the specified account.
		    /// </summary>
		    /// <param name="accountSid">The SID of the account.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="value">The value to set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retry attempts.</param>
		    /// <returns>The operation result of setting the account policy.</returns>
		    public static GroupPolicyUpdateResult SetAccountPolicy(string accountSid, string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.ThisComputersLocalUserOrGroup, accountSid, /* isMachine */ false, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the account policy for the specified account.
		    /// </summary>
		    /// <param name="accountSid">The SID of the account.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="retryCount">The number of retry attempts.</param>
		    /// <returns>The operation result of deleting the account policy.</returns>
		    public static GroupPolicyDeleteResult DeleteAccountPolicy(string accountSid, string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.ThisComputersLocalUserOrGroup, accountSid, /* isMachine */ false, subKey, valueName, retryCount);
		}

		// Machine Policy (for Remote Computer)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the group policy for a remote machine.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <returns>The group policy query result.</returns>
		    public static GroupPolicyQueryResult GetRemoteMachinePolicy(string remoteComputerName, string subKey, string valueName)
		        => GetGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ true, subKey, valueName, false);

		    /// <summary>
		    /// Retrieves multiple group policy values from a remote machine.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetRemoteMachinePolicies(string remoteComputerName, string subKey, string valueNamePrefix)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ true, subKey, valueNamePrefix, false);

		    /// <summary>
		    /// Sets the group policy for a remote machine.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="value">The value to set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The group policy operation result.</returns>
		    public static GroupPolicyUpdateResult SetRemoteMachinePolicy(string remoteComputerName, string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ true, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the group policy for a remote machine.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The group policy operation result.</returns>
		    public static GroupPolicyDeleteResult DeleteRemoteMachinePolicy(string remoteComputerName, string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ true, subKey, valueName, retryCount);
		}

		// User Policy (for Remote Computer)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Retrieves the user policy from a remote computer.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <returns>The query result of the user policy.</returns>
		    public static GroupPolicyQueryResult GetRemoteUserPolicy(string remoteComputerName, string subKey, string valueName)
		        => GetGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ false, subKey, valueName, false);

		    /// <summary>
		    /// Retrieves multiple group policy values from a remote user.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetRemoteUserPolicies(string remoteComputerName, string subKey, string valueNamePrefix)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ false, subKey, valueNamePrefix, false);

		    /// <summary>
		    /// Sets the user policy on a remote computer.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="value">The value to be set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The operation result of setting the user policy.</returns>
		    public static GroupPolicyUpdateResult SetRemoteUserPolicy(string remoteComputerName, string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ false, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the user policy from a remote computer.
		    /// </summary>
		    /// <param name="remoteComputerName">The name of the remote computer.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The operation result of deleting the user policy.</returns>
		    public static GroupPolicyDeleteResult DeleteRemoteUserPolicy(string remoteComputerName, string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.RemoteComputer, remoteComputerName, /* isMachine */ false, subKey, valueName, retryCount);
		}

		// Machine Policy (for Directory Service)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the machine policy from the directory service.
		    /// </summary>
		    /// <param name="path">The path to the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <returns>The query result of the machine policy.</returns>
		    public static GroupPolicyQueryResult GetDirectoryMachinePolicy(string path, string subKey, string valueName)
		        => GetGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ true, subKey, valueName, false);

		    /// <summary>
		    /// Retrieves multiple group policy values from the directory service for the specified machine.
		    /// </summary>
		    /// <param name="path">The path to the directory service.</param>
		    /// <param name="subKey">The subkey of the group policy values.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetDirectoryMachinePolicies(string path, string subKey, string valueNamePrefix)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ true, subKey, valueNamePrefix, false);

		    /// <summary>
		    /// Sets the machine policy in the directory service.
		    /// </summary>
		    /// <param name="path">The path to the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="value">The value to set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The operation result of setting the machine policy.</returns>
		    public static GroupPolicyUpdateResult SetDirectoryMachinePolicy(string path, string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ true, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the machine policy from the directory service.
		    /// </summary>
		    /// <param name="path">The path to the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="retryCount">The number of retries.</param>
		    /// <returns>The operation result of deleting the machine policy.</returns>
		    public static GroupPolicyDeleteResult DeleteDirectoryMachinePolicy(string path, string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ true, subKey, valueName, retryCount);
		}

		// User Policy (for Directory Service)
		partial class GroupPolicy
		{
		    /// <summary>
		    /// Gets the user policy from the directory service.
		    /// </summary>
		    /// <param name="path">The path of the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <returns>The query result of the user policy.</returns>
		    public static GroupPolicyQueryResult GetDirectoryUserPolicy(string path, string subKey, string valueName)
		        => GetGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ false, subKey, valueName, false);

		    /// <summary>
		    /// Retrieves multiple group policy values for a directory user.
		    /// </summary>
		    /// <param name="path">The path of the directory service.</param>
		    /// <param name="subKey">The subkey of the group policy.</param>
		    /// <param name="valueNamePrefix">The prefix of the value names to retrieve.</param>
		    /// <returns>The result of the multiple group policy query.</returns>
		    public static MultipleGroupPolicyQueryResult GetDirectoryUserPolicies(string path, string subKey, string valueNamePrefix)
		        => GetGroupPoliciesInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ false, subKey, valueNamePrefix, false);

		    /// <summary>
		    /// Sets the user policy in the directory service.
		    /// </summary>
		    /// <param name="path">The path of the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="value">The value to be set.</param>
		    /// <param name="requireExpandString">Specifies whether require expand string.</param>
		    /// <param name="retryCount">The number of retry attempts.</param>
		    /// <returns>The operation result of setting the user policy.</returns>
		    public static GroupPolicyUpdateResult SetDirectoryUserPolicy(string path, string subKey, string valueName, object value, bool requireExpandString, int retryCount = DefaultRetryCount)
		        => SetGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ false, subKey, valueName, value, requireExpandString, retryCount);

		    /// <summary>
		    /// Deletes the user policy from the directory service.
		    /// </summary>
		    /// <param name="path">The path of the directory service.</param>
		    /// <param name="subKey">The subkey of the policy.</param>
		    /// <param name="valueName">The name of the value.</param>
		    /// <param name="retryCount">The number of retry attempts.</param>
		    /// <returns>The operation result of deleting the user policy.</returns>
		    public static GroupPolicyDeleteResult DeleteDirectoryUserPolicy(string path, string subKey, string valueName, int retryCount = DefaultRetryCount)
		        => DeleteGroupPolicyInternal(GroupPolicyLocation.DirectoryService, path, /* isMachine */ false, subKey, valueName, retryCount);
		}
		
		/// <summary>
		/// Represents the result of a group policy delete operation.
		/// </summary>
		public enum GroupPolicyDeleteResult
		{
		    /// <summary>
		    /// The group policy delete operation succeeded.
		    /// </summary>
		    DeleteSucceed = 0,

		    /// <summary>
		    /// No item found to delete.
		    /// </summary>
		    NoItemFound,

		    /// <summary>
		    /// Failed to create or open the group policy.
		    /// </summary>
		    CreateOrOpenFailed,

		    /// <summary>
		    /// Failed to save the group policy.
		    /// </summary>
		    SaveFailed,
		}

		internal sealed class GetGroupPolicyThreadProcContext
		{
		    public GroupPolicyLocation Location { get; set; }
		    public string LocationParameter { get; set; } = string.Empty;
		    public bool IsMachine { get; set; }
		    public string SubKey { get; set; } = string.Empty;
		    public string ValueName { get; set; } = string.Empty;
		    public bool UseCriticalPolicySection { get; set; } = false;
		    public GroupPolicyQueryResult Result { get; set; } = new GroupPolicyQueryResult();
		}

		internal sealed class GetGroupPoliciesThreadProcContext
		{
		    public GroupPolicyLocation Location { get; set; }
		    public string LocationParameter { get; set; } = string.Empty;
		    public bool IsMachine { get; set; }
		    public string SubKey { get; set; } = string.Empty;
		    public string ValueNamePrefix { get; set; }
		    public bool UseCriticalPolicySection { get; set; } = false;
		    public MultipleGroupPolicyQueryResult Result { get; set; } = new MultipleGroupPolicyQueryResult();
		}

		internal sealed class SetGroupPolicyThreadProcContext
		{
		    public GroupPolicyLocation Location { get; set; }
		    public string LocationParameter { get; set; } = string.Empty;
		    public bool IsMachine { get; set; }
		    public string SubKey { get; set; } = string.Empty;
		    public string ValueName { get; set; } = string.Empty;
		    public object Value { get; set; } = default!;
			public bool RequireExpandString { get; set; } = default;
		    public int RetryCount { get; set; } = GroupPolicy.DefaultRetryCount;
		    public GroupPolicyUpdateResult Result { get; set; } = GroupPolicyUpdateResult.UpdateSucceed;
		}

		internal sealed class DeleteGroupPolicyThreadProcContext
		{
		    public GroupPolicyLocation Location { get; set; }
		    public string LocationParameter { get; set; } = string.Empty;
		    public bool IsMachine { get; set; }
		    public string SubKey { get; set; } = string.Empty;
		    public string ValueName { get; set; } = string.Empty;
		    public int RetryCount { get; set; } = GroupPolicy.DefaultRetryCount;
		    public GroupPolicyDeleteResult Result { get; set; } = GroupPolicyDeleteResult.DeleteSucceed;
		}
		
		[AttributeUsage(AttributeTargets.Field)]
		internal sealed class PolicyEnumValueAttribute : Attribute
		{
			public PolicyEnumValueAttribute(object value, bool isDeleteValue)
				: base()
			{
				_value = value;
				_isDeleteValue = isDeleteValue;
			}
			
			private readonly object _value;
			private readonly bool _isDeleteValue;
			
			public object Value { get { return _value; } }
			public bool IsDeleteValue { get { return _isDeleteValue; } }
		}
		""";

    public static string GetHelperCodes() => """
		internal static class Helpers
		{
			public static object TranslateFromEnum<T>(T? enumValue)
				where T : struct, Enum
			{
				if (enumValue == null) return null;
				Type enumType = typeof(T);
				FieldInfo[] memberFields = enumType.GetFields();
				for (int i = 0; i < memberFields.Length; i++)
				{
					object[] customAttributes = memberFields[i].GetCustomAttributes(true);
					PolicyEnumValueAttribute attr = customAttributes.FirstOrDefault(x => x is PolicyEnumValueAttribute) as PolicyEnumValueAttribute;
					if (attr == null)
						continue;
					if (!object.Equals(enumValue, memberFields[i].GetValue(null)))
						continue;
					return attr.Value;
				}
				return null;
			}
			
			public static T? TranslateToEnum<T>(object translatedValue)
				where T : struct, Enum
			{
				Type enumType = typeof(T);
				FieldInfo[] memberFields = enumType.GetFields();
				for (int i = 0; i < memberFields.Length; i++)
				{
					object[] customAttributes = memberFields[i].GetCustomAttributes(true);
					PolicyEnumValueAttribute attr = customAttributes.FirstOrDefault(x => x is PolicyEnumValueAttribute) as PolicyEnumValueAttribute;
					if (attr == null)
						continue;						
					if (!object.Equals(attr.Value, translatedValue))
						continue;
					return (T)memberFields[i].GetValue(null);
				}
				return null;
			}
		}
		""";
}
